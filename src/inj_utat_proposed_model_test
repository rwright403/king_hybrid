#thank you for the incredible thesis: https://emersonvn.com/project/two_phase_injector/

#I love coolprop! ~ units: http://www.coolprop.org/v4/apidoc/CoolProp.html

import CoolProp.CoolProp as CP
from rocketprops.rocket_prop import get_prop #NOTE: just using because CP doesn't have nitrous viscosity
from rocketprops.rocket_prop import Propellant
import matplotlib.pyplot as plt
import numpy as np

def secant(func, x1):
    x_eps = x1 * 0.005  # Set the tolerance to be 0.5% of init guess
    x2 = x1 -x1 * 0.01  # Set a second point 1% away from the original guess
    F1 = func(x1)  # Evaluate function at x1
    F2 = func(x2)  # Evaluate function at x2
    kk = 1  # Set up counter
    kk_max = 1000

    while np.abs(x2 - x1) >= (x_eps) and kk < kk_max:  # While error is too large and counter is less than max
        x3 = x2 - (F2 * (x2 - x1) / (F2 - F1)) 
        x1 = x2  # Move everything forward
        x2 = x3
        F1 = F2
        F2 = func(x2) 
        kk = kk + 1
    x = x2
    return x

def HIGHSUBCOOLEDerror(eta_crit, omega):
    print(eta_crit)
    function_diff = 0 - (eta_crit**2) + ((omega**2)-2*omega)*(1-eta_crit)**2 + 2*(omega**2)*np.log(eta_crit) + 2*(omega**2)*(1-eta_crit)
    return function_diff

def LOWSUBCOOLEDerror(eta_crit, eta_sat, omega):
    function_diff = 0 - (((omega+(1/omega)-2)/(2*eta_sat))*eta_crit**2) - (2*(omega - 1)*eta_crit) + (omega*eta_sat*np.log(eta_crit/eta_sat)) + ((3/2)*omega*eta_sat) - 1
    return function_diff

#constants:
all_err = 0.01

m_ox = 5.73815484158 #kg 
#NOTE: GUESSING Cd
Cd_ox =  0.6
A_inj_ox = 3.090605599220321e-5 #m^2
V_tank = 0.01177057403 #m^3

#start (using SI units)

#evaluate upstream stagnation inlet conditions
P_1 = 52e5 #Pa
P_2 = 101325 #Pa
T_1 = 275 #K
rho_1 = m_ox/V_tank
v_1 = 1/rho_1

#solve quality:
v_1_g = 1/CP.PropsSI('D', 'Q', 1, 'P', P_1, 'N2O')
v_1_l = 1/CP.PropsSI('D', 'Q', 0, 'P', P_1, 'N2O')
v_1_lg = v_1_g - v_1_l

x_1 = (v_1 - v_1_g ) / v_1_lg

h_1_g = CP.PropsSI('H', 'Q', 1, 'P', P_1, 'N2O')
h_1_l = CP.PropsSI('H', 'Q', 0, 'P', P_1, 'N2O')
h_1_lg = h_1_g - h_1_l

h_1 = h_1_g + x_1 * h_1_lg

c_1_l = CP.PropsSI('CVMASS', 'Q', 0, 'P', P_1, 'N2O') #BUG: ? assuming specific heat capacity at constant volume, thesis wasnt clear, might be a mistake

#check saturated vs subcooled?
#if x >= 1 #subcooled
#solve physical parameters and void fraction



# Step 1, solve omega model's eta_sat:

omega_sat = x_1*v_1_lg/v_1 + (c_1_l*T_1*P_1/v_1)*(v_1_lg/h_1_lg)**2

eta_sat =  2 * omega_sat / ( 1 + 2* omega_sat)

#Step 2, Determine inlet state:

#NOTE: is this just coolprop for sat vs subcooled:

#if saturated ???

#solve saturation pressure (check tomorrow, this might be wrong)

P_sat = P_2 / eta_sat

P_crit = None 
m_dot = None

eta_crit = P_2/P_1 #initial guess

# High subcooled
if P_sat < eta_sat * P_1:

    omega_high = (c_1_l*T_1*P_1/v_1)*(v_1_lg/h_1_lg)**2

    #implicitly solve eta_crit
    while np.abs(HIGHSUBCOOLEDerror(eta_crit, omega_high) ) > all_err:
        eta_crit = secant((lambda T: HIGHSUBCOOLEDerror(T, omega_high)), eta_crit)

    # Choked:
    m_dot = A_inj_ox * np.sqrt( P_1 * (1/v_1_l) ) * eta_crit / np.sqrt(omega_high)

# Low subcooled
if P_sat > eta_sat * P_1:

    #implicitly solve eta_crit
    while np.abs(LOWSUBCOOLEDerror(eta_crit, eta_sat, omega_sat) ) > all_err:
        eta_crit = secant((lambda T: LOWSUBCOOLEDerror(T, eta_sat, omega_sat)), eta_crit)

    # Choked:
    m_dot = (1/np.sqrt(P_1/v_1_l)) * np.sqrt( (2*(1-eta_sat)) + 2*(omega_sat*eta_sat*np.log(eta_sat/eta_crit) - (omega_sat-1)*(eta_sat-eta_crit)) ) / ( ((omega_sat*eta_sat)/(eta_crit-1)) + 1)


P_crit = eta_crit * P_1

# Choked:
m_dot = A_inj_ox * np.sqrt( P_1 * (1/v_1_l) ) * eta_crit / np.sqrt(omega_high)


# Check if choked, if not use Dyer model
if P_crit < P_2:

    # SPI MODEL
    rho_2_spi = CP.PropsSI('D', 'H', h_1, 'P', P_1, 'N2O') #is isentropic valid for this model?
    m_dot_spi = Cd_ox * A_inj_ox * np.sqrt( 2 * rho_2_spi * (P_1 - P_2)  )

    # HEM MODEL
    s_2 = CP.PropsSI('S', 'H', h_1, 'P', P_1, 'N2O') #assuming isentropic, upstream entropy equals downstream entropy
    h_2_hem = CP.PropsSI('H', 'S', s_2, 'P', P_1, 'N2O')
    rho_2_hem = CP.PropsSI('D', 'S', s_2, 'P', P_1, 'N2O')

    m_dot_hem = Cd_ox * A_inj_ox * rho_2_hem * np.sqrt( 2 * (h_1 -  h_2_hem) )
                    
    # Dyer MODEL 
    dyer_k = np.sqrt( (P_1 - P_2) / ( CP.PropsSI('P', 'Q', 1, 'T', T_1, 'N2O') - P_2) ) #call coolprop to get vapor pressure          
    m_dot = ((dyer_k/(1+dyer_k)) * m_dot_spi) + ((1/(1+dyer_k)) * m_dot_hem)

    #smoothing function?? (wouldnt be structured in separate scopes if so)

print(m_dot)
